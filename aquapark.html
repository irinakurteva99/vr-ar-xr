<!DOCTYPE html>

<html>

<head>
    <title>Аквапарк</title>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script type="importmap">
		  {
			"imports": {
			  "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
			  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
			  "vax": "https://boytchev.github.io/CourseVAX/lib/vax.js"
			}
		  }
	</script>
</head>
<!-- 
    Всички текстури са от www.freepik.com
-->

<body>
    <script type="module">

        import * as THREE from "three";
        import * as VAX from "vax";

        VAX.initParallax(animate, -3);
        // VAX.init(animate)
        var group = new THREE.Group();

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 50, 50);
        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 200;

        group.add(dirLight);

        VAX.scene.add(group);
        VAX.renderer.shadowMap.enabled = true;
        const textureLoader = new THREE.TextureLoader();

        const tilesTexture = textureLoader.load('textures/tiles.jpg')
        var ground = new THREE.Mesh(
            new THREE.BoxGeometry(100, 0.5, 100),
            new THREE.MeshStandardMaterial({ map: tilesTexture })
        );
        ground.position.set(0, -20, -3);
        ground.receiveShadow = true;
        group.add(ground);

        var pool = new THREE.Group();
        const poolBase = new THREE.Mesh(
            new THREE.BoxGeometry(40, 6, 60),
            new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.9,
                metalness: 0
            })
        );
        poolBase.position.set(-20, -17, -3);
        poolBase.receiveShadow = true;
        pool.add(poolBase);

        const waterTexture = textureLoader.load('textures/water.jpg')
        const water = new THREE.Mesh(
            new THREE.PlaneGeometry(38, 56),
            new THREE.MeshStandardMaterial({
                map: waterTexture,
                transparent: true,
                opacity: 0.5,
                roughness: 0.1
            })
        );
        water.rotation.x = -Math.PI / 2;
        water.position.set(-20, -13.9, -3);
        water.receiveShadow = true;
        pool.add(water);
        group.add(pool);

        const slideMat = new THREE.MeshStandardMaterial({
            color: 0xff6f61,
            roughness: 0.5,
            metalness: 0.3,
            side: THREE.DoubleSide
        });

        var slide = new THREE.Group();
        const slide1 = new THREE.Mesh(
            new THREE.TorusGeometry(
                22,
                3.5,
                16,
                80,
                Math.PI * 0.7
            ),
            slideMat
        );
        slide1.rotation.set(Math.PI / 3, 0, -Math.PI / 2);
        slide1.position.set(5, 19, -15);
        slide.add(slide1);

        const slide2 = new THREE.Mesh(
            new THREE.TorusGeometry(
                22,
                3.5,
                16,
                80,
                Math.PI * 0.5
            ),
            slideMat
        );

        slide2.rotation.set(-Math.PI / 3, Math.PI, 0);
        slide2.position.set(6, -3, -15);
        slide.add(slide2);

        const slideExit = new THREE.Mesh(
            new THREE.TorusGeometry(
                22,
                3.5,
                16,
                80,
                0.5
            ),
            slideMat
        );
        slideExit.rotation.set(-Math.PI / 3, Math.PI / 2, Math.PI);
        slideExit.position.set(-16, -21.5, -27);
        slide.add(slideExit);
        group.add(slide);

        var tower = new THREE.Group();

        const towerTexture = textureLoader.load('textures/tower.jpg')
        const towerHeight = 50;
        const towerRadiusTop = 5;
        const towerRadiusBottom = 7;
        const towerSegments = 32;

        const towerElem = new THREE.Mesh(
            new THREE.CylinderGeometry(towerRadiusTop, towerRadiusBottom, towerHeight, towerSegments),
            new THREE.MeshStandardMaterial({ map: towerTexture })
        );
        towerElem.rotation.y = Math.PI;
        towerElem.position.set(23, 5, -3);
        tower.add(towerElem);

        const platformCount = 4;
        for (let i = 1; i <= platformCount; i++) {
            const platformHeight = 1;
            const platformRadius = 7 + 0.1 * 20 * (platformCount - i);

            const platformElem = new THREE.Mesh(
                new THREE.CylinderGeometry(platformRadius, platformRadius, platformHeight, 32),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd35efc,
                    roughness: 0.5,
                    metalness: 0
                })
            );

            platformElem.position.set(23, (i * towerHeight) / (platformCount + 1) - 23, -3);
            tower.add(platformElem);
        }

        group.add(tower);

        const beam = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 27, 16),
            new THREE.MeshStandardMaterial({ color: 0x804518 })
        );
        beam.position.set(10, -7, -35);
        beam.rotation.y = Math.PI / 2;
        group.add(beam);

        function createHuman() {
            const human = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: 0xffd997, roughness: 0.8 });

            const bodyGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2.6, 16);
            const body = new THREE.Mesh(bodyGeometry, material);
            body.position.y = 1.3 + 1.5;
            human.add(body);

            const headGeometry = new THREE.SphereGeometry(1, 16, 16);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = body.position.y + 1.3 + 1;
            human.add(head);

            const armGeometry = new THREE.CylinderGeometry(0.3, 0.3, 3, 12);

            const leftArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-1.1, body.position.y + 0.5, 0);
            leftArm.rotation.z = Math.PI / 2.5;
            human.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, material);
            rightArm.position.set(1.1, body.position.y + 0.5, 0);
            rightArm.rotation.z = -Math.PI / 2.5;
            human.add(rightArm);
            return human;
        }

        function getRandomPositionInPool() {
            const x = -35 + Math.random() * 30;
            const z = Math.random() * 20;
            return new THREE.Vector3(x, -16, z);
        }

        const humans = [];
        for (let i = 0; i < 10; i++) {
            const position = getRandomPositionInPool();
            const human = createHuman();
            human.castShadow = true;
            human.position.copy(position);
            humans.push(human);
            group.add(human);
        }

        function createTicketHouse() {
            const house = new THREE.Group();

            const wallGeom = new THREE.BoxGeometry(10, 8, 10);
            const woodTexture = textureLoader.load('textures/wood.jpg');
            const wallMat = new THREE.MeshStandardMaterial({ map: woodTexture });
            const walls = new THREE.Mesh(wallGeom, wallMat);
            house.add(walls);

            const roofTexture = textureLoader.load('textures/roof.jpg');
            const roofGeom = new THREE.ConeGeometry(10, 4, 4);
            const roofMat = new THREE.MeshStandardMaterial({ map: roofTexture });
            const roof = new THREE.Mesh(roofGeom, roofMat);
            roof.position.y = 6;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);

            const doorGeom = new THREE.BoxGeometry(2, 4, 0.2);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const door = new THREE.Mesh(doorGeom, doorMat);
            door.position.set(0, -2, 5 + 0.1);
            house.add(door);

            return house;
        }

        const ticketHouse = createTicketHouse();
        ticketHouse.position.set(30, -16, 30);
        group.add(ticketHouse);


        humans.forEach(h => {
            h.traverse(child => {
                if (child.isMesh) child.castShadow = true;
            });
        });

        slide.traverse(child => {
            if (child.isMesh) child.castShadow = true;
        });

        beam.castShadow = true;

        tower.traverse(child => {
            if (child.isMesh) child.castShadow = true;
        });
        pool.traverse(child => {
            if (child.isMesh) child.castShadow = true;
        });
        ticketHouse.traverse(child => {
            if (child.isMesh) child.castShadow = true;
        });

        function animate(t) {
            group.rotation.set(0, t / 4, 0);
            humans.forEach((h, index) => {
                h.position.y = -16 + Math.sin(t * 2 + index) * 0.5;
            });

        }
    </script>
</body>

</html>